---
title: 'Java中的各种锁'
date: 2020-07-12
permalink: /posts/2020/07/Java中的各种锁/
tags:
  - Java
---

乐观锁和悲观锁
======

Def：乐观锁和悲观锁最早出现在数据库的设计当中，后来逐渐被Java并发包【 J.U.C】所引入，悲观锁和乐观锁并不是某个具体的“锁”而是一种并发编程的基本概念。

1. 悲观锁（Pessimistic Lock）

悲观锁认为对于同一个数据的并发操作，一定会发生修改，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观地认为，不加锁的并发一定会出问题。

2. 乐观锁（Optimistic Lock）

乐观锁正好和悲观锁相反，它获取数据时，并不担心数据被修改，每次获取数据的时候也不会加锁，只是在更新数据的时候，通过判断现有的数据是否和元数据一致来判断是否被其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新。

公平锁和非公平锁
======

Def：根据线程获取锁的抢占机制，锁又可以分为公平锁和非公平锁

1. 公平锁（FairSync）：公平锁是指多个线程按照申请锁的顺序来获取锁。
2. 非公平锁（NonfairSync）：非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。

ReentrantLock提供了公平锁和非公平锁的实现（如果构造函数传任何参数的时候，默认提供的是非公平锁）

1. 公平锁（FairSync）：new ReentrantLock(true)
2. 非公平锁（NonfairSync）：new ReentrantLock(false)

在Java程序中比较常用的非公平锁而非公平锁，原因在与非公平锁的吞吐量要更大，并且发生线程“饥饿”的情况很少，是风险远小于收益的事，所以可以广而用值。

独占锁和共享锁
======

Def：根据锁能否被多个线程持有，可以把锁分为独占锁和共享锁。

1. 独占锁：是指任何时候都只有一个线程能够执行资源操作。
2. 共享锁：指定可以同时被多个线程读取，但只能被一个线程修改。比如Java中的ReentrantReadWriteLock就是共享锁的实现方式，它允许【一个线程】进行写操作，允许【多个线程】读操作

可重入锁
======


可重入锁指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码。

自旋锁
======
自旋锁是指尝试获取锁的线程不会立刻阻塞，而是采取循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的销毁，缺点是循环会销毁CPU。

CAS与ABA
======

CAS（Compare and Swap）比较并交换，是一种乐观锁的实现，是用非阻塞算法来代替锁定，其中java.util.concurrent包下面的AtomicInteger就是借助CAS来实现的。CAS有一个副作用，著名的ABA问题就是CAS引起的。

ABA问题描述
======
A去银行拿钱，余额有1000，A取了100块。但是因为程序问题，启动了两个线程，线程①和线程②进行比对扣款，线程①获取原本有200块，扣除100块，余额等于900块。此时B给A转账100块，于是启动了线程③抢先在线程②之前执行转账操作，把900块又变成了1000块，此时线程②对比自己事先拿到的1000块和此时经过改动的1000块值一样，就进行了减法操作，把余额又编程了900块。这显然不是我们要的正确结果，我们想要的结果是余额减少100块，又增加100块，余额还是1000块，但是此时余额编程了100块，显然有悖常理，这就是著名的ABA问题。

ABA问题的解决方案
======
常见解决ABA问题的方案加版本号，来区分值是否有变动，以上面取钱为例，如果加上版本号，执行流程如下：

1. 线程一：取款获得原值 1000_v1，和1000_v1对比，减去100块，修改结果为900_v2
2. 线程二：取款，获得原值 1000_v1阻塞等待修改
3. 线程三：转账，获取原值 900_v2，与900_v2对比成功，加100块，修改结果为1000_v3
4. 线程二：取款，恢复执行，原值1000_v1与现值1000_v3对比不相等，退出修改。

最终得到结果1000，是我们需要的结果。在程序中，要怎么解决ABA问题，在JDK 1.5的时候，Java的atomic里面提供了AtomicStampedReference原子引用变量，通过添加版本号来解决ABA.

```java
String name = "A";
String newName = "Java";
AtomicStampedReference<String> as = new AtomicStampedReference<String>(name, 1);
System.out.println("值：" + as.getReference() + " | Stamp：" + as.getStamp());
as.compareAndSet(name, newName, as.getStamp(), as.getStamp() + 1);
System.out.println("值：" + as.getReference() + " | Stamp：" + as.getStamp());
```

执行结果：

```java
值：A | Stamp: 1
值：Java | Stamp: 2
```

相关面试题
======
1. Synchronized是哪种锁实现？为什么？

> Synchronized是悲观锁的实现, 因为Synchronized修饰的代码，每次执行时会进行加锁操作，同时只允许一个线程进行操作，所以它是悲观锁的实现。

2. new ReentrantLock() 创建的是公平锁还是非公平锁？

> 非公平锁，如下面ReentrantLock的实现源码：
>
> ```java
> /**
>  * Creates an instance of {@code ReentrantLock}.
>  * This is equivalent to using {@code ReentrantLock(false)}.
>  */
> public ReentrantLock() {
>     sync = new NonfairSync();
> }
> ```

3. Synchronized使用的是公平锁还是非公平锁？

> Synchronized使用的是非公平锁，并且是不可设置的。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统【线程调度】的基本选择，所以这也是Synchronized使用非公平锁原由。

4. 为什么非公平锁吞吐量大于公平锁？

>比如A占用锁的时候，B请求获取锁，发现被A占用之后，堵塞等待被唤醒，这个时候C同时来获取A占用的锁，如果是公平锁C后来者发现不可用之后一定排在B之后等待被唤醒，而非公平锁则可以让C先用，在B被唤醒之前C已经使用完成了，从而节省了C等待和唤醒之间的性能消耗，这就是非公平锁比公平锁吞吐量大的原因。

5. Volatile的作用是什么？

> Volatile是Java虚拟机提供的【最轻量级的同步机制】。当变量被定义为Volatile之后，具备两种特性：
>
> + 保证此变量对所有线程的【可见性】，当一条线程修改了这个变量的值，修改的新值对于其他线程是可见的（可以立即得知的）；
> + 【禁止指令重排序优化】，普通变量仅仅能保证在该方法执行过程中，得到正确结果，但不保证程序代码的执行顺序。

6. Volatile对比Syncronized有什么区别？

> Syncronized既能保证【可见性】，又能保证【原子性】，而Volatile只能保证【可见性】，无法保证【原子性】。比如，i++如果使用【Synchronized修饰是线程安全】的，而【Volatile不是线程安全】。

7. CAS是如何实现的？

> CAS(Compare and Swap)比较并交换，CAS是通过调用 JNI（Java Native Interface）的代码来实现的，比如，在Windows系统CAS就是借助C语言来调用CPU底层指令实现的。

8. CAS会产生什么问题？应该如何解决？

> CAS是标准的乐观锁的实现，会产生ABA问题。ABA通常的解决办法是添加版本号，每次修改操作时版本号 + 1，这样数据对比的时候就不会出现ABA问题了。

9. 常考点

> + 独占锁是指任何时候都只有一个线程能执行资源操作。
> + 共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。
> + 公平锁是指多个线程按照申请锁的顺序来获取锁。
> + 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程会比先申请的线程优先获取锁。
------