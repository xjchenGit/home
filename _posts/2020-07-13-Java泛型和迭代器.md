---
title: 'Java泛型和迭代器'
date: 2020-07-13
permalink: /posts/2020/07/Java泛型和迭代器/
tags:
  - Java
---

### 泛型

#### 为什么要用泛型？

如果没有使用泛型，我们经常会遇到以下的问题：

```java
ArrayList arrayList = new ArrayList();
arrayList.add("Java");
arrayList.add(24);
for (int i = 0; i < arrayList.size(); i++) {
  String str = (String) arrayList.get(i);
  System.out.println(str);
}

//执行结果
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
at xxx(xxx.java:12)
```

类型转换出错，当我们给ArrayList放入不同类型的数据，却使用一种类型进行接收的时候，就会出现很多类似的错误，可能更多的时候，是因为开发人员的不小心导致的。Java语言的“泛型”，就是可以杜绝此类问题的发生。

#### 泛型介绍

**泛型：**泛型本质上是类型参数化，解决了不确定对象的类型问题。

```java
ArrayList<String> arrayList = new ArrayList();
arrayList.add("Java");
```

这时候如果给arrayList添加非String类型的元素，编译器就会报错，提醒开发人员插入相同类型的元素。报错信息如下图所示，这样就避免开头示例中，类型不一致导致程序运行过程中报错的问题：

<img src="https://raw.githubusercontent.com/VictorChan1/blogImg/master/img/image-20200713003555665.png" alt="image-20200713003555665" style="zoom: 33%;" />

#### 泛型的优点

泛型的优点主要有以下三个方面：

+ 安全：不用担心程序运行过程中出现类型转换的错误。
+ 避免了类型转换：如果是非泛型，获取到的元素是Object类型的，需要强制类型转换。
+ 可读性高：编码阶段就明确的知道集合中元素的类型。

### 迭代器（Iterator）

#### 为什么要用迭代器？

在迭代器（Iterator）没有出现之前，如果要遍历数组和集合，需要使用方法。

**数组遍历**

```java
String[] arr = new String[]{"Java", "Java虚拟机", "Java中文社群"};
for (int i = 0; i < arr.length; i++) {
    String item = arr[i];
}
```

**集合遍历**

```java
List<String> list = new ArrayList<String>() {{
    add("Java");
    add("Java虚拟机");
    add("Java中文社群");
}};
for (int i = 0; i < list.size(); i++) {
    String item = list.get(i);
}
```

**迭代器：**为了不同类型的容器遍历，提供标准统一的方法。

```java
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
    Object object = iterator.next();
    // do something
}
```

**总结：**使用了迭代器就可以不用关注容器的内部细节，用同样的方式遍历不同类型的容器。

#### 迭代器介绍

迭代器是用来遍历容器内所有元素对象的，也是一种常用的设计模式。它包含以下四个方法：

+ hasNext ()：boolean —— 容器内是否还有可以访问的元素。
+ next ()：E ——返回下一个元素
+ remove ()：void —— 删除当前元素。
+ forEachRemaining (Consumer)：void —— JDK8 中添加的，提供一个lambda表达式遍历容器元素。

迭代器使用如下：

```java
List<String> list = new ArrayList<String>() {{
    add("Java");
    add("Java虚拟机");
    add("Java中文社群");
}};
Iterator iterator =  list.iterator();
// 遍历
while (iterator.hasNext()){
    String str = (String) iterator.next();
    if (str.equals("Java中文社群")){
        iterator.remove();
    }
}
System.out.println(list);

// 执行结果：[Java, Java虚拟机]

// forEachRemaining 使用
List<String> list = new ArrayList<String>() {{
    add("Java");
    add("Java虚拟机");
    add("Java中文社群");
}};
// forEachRemaining 使用
list.iterator().forEachRemaining(item -> System.out.println(item));
```

### 相关面试题

1. 为什么迭代器的next () 返回的是Object类型？

因为迭代器不需要关注容器的内部细节，所以next () 返回Object类型就可以接收任何类型的对象。

2. HashMap的遍历方式都有几种？
   + 方式一：entrySet遍历
   + 方式二：iterator遍历
   + 方式三：遍历所有的Key和Value
   + 方式四：通过Key值遍历

```java
Map<String, String> hashMap = new HashMap();
hashMap.put("name", "Victor");
hashMap.put("sex", "man");
// 方式一：entrySet 遍历
for (Map.Entry item : hashMap.entrySet()) {
  System.out.println(item.getKey() + ":" + item.getValue());
}
// 方式二：iterator 遍历
Iterator<Map.Entry<String, String>> iterator = hashMap.entrySet().iterator();
while (iterator.hasNext()) {
  Map.Entry<String, String> entry = iterator.next();
  System.out.println(entry.getKey() + ":" + entry.getValue());
}
// 方式三：通过 key 值遍历
for (Object k : hashMap.keySet()) {
  // 循环所有的 key
  System.out.println(k);
}
for (Object v : hashMap.values()) {
  // 循环所有的值
  System.out.println(v);
}
// 方式四：遍历所有的 key 和 value
for (Object k : hashMap.keySet()) {
  System.out.println(k + ":" + hashMap.get(k));
}
```

3. 以下泛型说法错误的是？

   A：泛型可以修饰类

   B：泛型可以修饰方法

   C：泛型不可以修饰接口

   D：以上说法全错

   > 泛型可以修饰类、方法、接口、变量
   >
   > ```java
   > public interface Iterable<T> { }
   > ```

4. 以下程序执行的结果是什么？

```java
List<String> list = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
System.out.println(list.getClass() == list2.getClass());
```

程序的执行结果是`true`

Java中泛型在编译时会进行类型擦除，因此 `List<String> list` 和 `List<Integer> list2` 类型擦除后的结果都是java.util.ArrayList，进而 list.getClass () == list2.getClass () 的结果也一点是 true。

5. `List<Object >` 和 `List<?>` 有什么区别？

`List <?>`可以容纳任意类型，只不过`List <?>` 被赋值之后，就不允许添加和修改操作了；而`List <Object>` 和 `List<?>` 不同的是它在赋值之后，可以进行添加和修改操作：

<img src="https://raw.githubusercontent.com/VictorChan1/blogImg/master/img/image-20200713012427448.png" alt="image-20200713012427448" style="zoom:33%;" />

6. 可以把 `List<String>` 赋值给 `List<Object>`吗？

   不可以，编译器会报错：

   <img src="https://raw.githubusercontent.com/VictorChan1/blogImg/master/img/image-20200713012550121.png" alt="image-20200713012550121" style="zoom:33%;" />

7. `List` 和 `List<Object>` 的区别是什么？

`List`和 `List<Object> `都能存储任意类型的数据，但 `List`和 `List<Object>`的唯一区别就是，`List`不会触发编译器的类型安全检查，比如把 `List<String>`赋值给 `List`是没有任何问题的，但赋值给 `List<Object>`就不行：

<img src="https://raw.githubusercontent.com/VictorChan1/blogImg/master/img/image-20200713012839411.png" alt="image-20200713012839411" style="zoom:33%;" />

8. 以下程序执行的结果？

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Java虚拟机");
list.add("Java中文社群");
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
    String str = (String) iterator.next();
    if (str.equals("Java中文社群")) {
        iterator.remove();
    }
}
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
System.out.println("Over");
```

程序打印结果：`Over`，因为第一个 while 循环之后，iterator.hasNext () 返回值就 false 了，所以不会进入第二循环，之后打印最后的Over。

9. 泛型的工作原理是什么？为什么要有类型擦除？

泛型是通过类型擦除来实现的，类型擦除指的是编译器在编译时，会擦除了所有类型相关的信息，比如 `List<String>` 在编译后就会变成 `List` 类型，这样做的目的就是确保能和 Java 5 之前的版本（二进制类库）就那些兼容。

### 总结

泛型的优点：安全性、避免类型转换、提高了代码的可读性。泛型的本质是类型参数化，但编译之后会执行类型擦除，这样就可以和 Java 5 之前的二进制类库进行兼容。本文也介绍了迭代器（Iterator）的使用，使用迭代器的好处是不用关注容器的内部细节，用同样的方式遍历不同类型的容器。
