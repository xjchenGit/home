---
title: 'MySQL须知'
date: 2020-07-11
permalink: /posts/2020/07/MySQL须知/
tags:
  - MySQL
---

概述
=====
[TOC]

### MySQL存储引擎『MyISAM和InnoDB的区别』

1. 【行级锁】MyISAM仅支持表锁，InnoDB支持表锁和行锁。

2. 【事务】

   + MyISAM不支持事务，且不具备【崩溃回复能力】
   + InnoDB支持事务，提供回滚和崩溃恢复。

3. 【外键】仅InnoDB支持外键。

4. 【MVCC】仅InnoDB支持MVCC。 【MVCC是多版本并发控制 Multi-Version Concurrency Control】

5. 【应用场景不同】

   + MyISAM适用【Select】频繁，并发少
   + InnoDB适用【Insert Delete Update】频繁，高并发

   因为

   + MyISAM仅缓存索引块，而InnoDB缓存「索引+数据」
   + InnoDB回表需要映射块，而MyISAM直接映射数据地址
   + InnoDB需要维护MVCC机制

6. MyISAM索引和InnoDB区别

   + MyISAM【索引】叶子节点 = 「Key, 行数据」
   + InnoDB【主键索引】叶子节点 = 「主键ID, data数据」
     + 因此InnoDB根据【主键索引】查询，不需要二次寻址，效率更高
   + InnoDB【二级索引】叶子节点 = 「Key, 主键ID」
     + 如果实现覆盖索引，即要查询列值：全部命中索引，则直接返回：非主键索引的内容
     + 如果未实现覆盖索引，则需要根据【主键ID】做回表

7. 【存储结构不同】
   + InnoDB存储结构 = 索引和数据（集中存储）
   + MyISAM存储结构 = 「表定义，MYD数据文件，MYI索引文件」
     + MyISAM是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表，就会在本地建立三个文件。
8. 不带Where条件时，【Count(*)效率不同】
   + MyISAM自带计数存储保持【总行数】，可直接返回结果
   + InnoDB扫描全表计算总行数

### 事务特性

事务符合ACID原则的一组操作

1. Atomicity

   + 事务是不可分割的最小单元，事务内所有操作要么全部执行成功，要么全部失败回滚

2. Isolation

   + 事务所作出的修改，在提交前，对于其他事务而言不可见

3. Durability

   + 事务一旦提交，所作出的修改是永久的。

4. Consistency

   + 系统从一个正确状态 -> 另一个正确状态
   + AID是数据库的特征，通过AID手段保证C这个目的

   【数据库】约束列值 *不能小于0*，则事务执行失败

   【应用层】约束 余额数据 *不能小于0*，则应用层通过事务回滚保证约束

   + 没有约束，则事务执行成功，且保持了一致性。因为没有破坏约束。

### 并发事务带来的问题

1. 脏读（Dirty Read）
   + 事务A修改数据，但并未Commit。而事务B读取该数据。
2. 丢失修改（Lost modification）
   + 事务A、B都读取同一数据。事务A、B先后修改数据，则第一次修改操作丢失。
3. 不可重复读（Non repeatable）
   + 事务A 共读取两次数据，而在这次读取之间。事务B修改了数据，则事务A两次读取到的数据不同。
4. 幻读（Illusory reading）
   + 事务A 读取【n行数据】，事务B在n行数据间添加数据。则事务A第二次读取时，读到n+1行

###  事务隔离级别

1. Read-Uncommitted 读取未提交

   无论事务是否提交，直接【读取主记录】

2. Read-committed 读取已提交

   【读取最新版本的快照】，快照是事务提交后产生的，但可能存在同一事务两次读取的快照不同。

   即并发问题 = 【不可重复读】+【幻影读】

3. Repeatable 可重复读

   【读取指定版本快照】，则事务多次读取某数据行的结果一致，但读取到的数据可能并非最新数据。

   即并发问题 = 【幻影读】

4. Serializable 可串行化

   上表锁，读写互相阻塞，效率低下。无并发问题。

InnoDB引擎默认实现，可重复读隔离级别

### MVCC

1. 目的：

   MVCC是行锁的变种，它想尽可能地避免加锁操作，实现【非阻塞】读。从而提高处理并发事务的性能。

2. MVCC实现隔离级别

   + MVCC仅 Read Commited & Repeatable read 两种隔离级别
   + Read uncommitted总是【读取最新】数据行，与MVCC的版本快照机制不符。
   + Serialtizable则 对读取的【数据行】都加锁，与MVCC尽可能避免加锁的原则不符合。

3. undolog：

   + 记录数据行的某个历史版本，undolog以链表形式存在
     + RC是读取 最新版本的undolog
     + RR是读取某一指定老版本的undolog

### 索引

索引的存储结构 = 「1.Hash表 2.B+树」

#### 6.1 hash索引

1. hash索引的实现

   底层数据结构 = hash表

   通过 hash 值定位数据行，产生碰撞则采用 linked-list 解决

2. hash索引的缺点

   + 适用于等值查询。但hash索引无法排序，因此不适用于范围查询，不支持最左匹配原则
   + 大量重复的键值，减低效率

#### 6.2 磁盘预读取

磁盘读取以【磁盘块】为基本单位。

【磁盘预读取】：每次读取多个【物理连续】的磁盘块。

B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。

一页空间 = 磁盘预读取的 多个磁盘块总和

从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数。

#### 6.3 为什么使用B+树，而不是B树  [Why](https://blog.csdn.net/qq_21993785/article/details/80580679)

1. MySQL根据【磁盘IO次数】衡量查询效率，而【B+树磁盘IO次数更少】

   因为 **B+树**【 非叶节点 = 「指针 + key」】

   而 B树中 【 非叶节点 = 「指针 + key + data数据」 】，

   每个节点（即每一页）存储空间有限，B树节点存储的key较少，出度较小

   因此**B树的节点较多（Key总量固定）**

   导致B树深度大，磁盘IO次数多。

2. B+树叶子节点通过指针连接，便于【区间访问】

   **B树结构**

![img](https://gitee.com/victorchan1/blogImg/raw/master/img/1392612-20190710184116315-1564718133.png)

​		**B+树结构**

![img](https://gitee.com/victorchan1/blogImg/raw/master/img/1392612-20190710184211574-1500980455.png)

#### 6.4为什么使用B+树，而不是红黑树

【B+树磁盘IO次数更少】

1. 红黑树的深度往往较大，而磁盘IO次数是和树高度成正比。

2. B树利用磁盘预读取特性，在建立节点时，申请【物理连接】的一页空间。

   一页空间 = 磁盘预读取的多个磁盘块总和

   从而【实现一次磁盘IO读取一个节点】，减少磁盘IO次数

3. 红黑树上逻辑比较相近的节点，其物理距离可能比较远，无法利用磁盘预读特性。

#### 6.5 聚簇索引和非聚簇索引、主键索引和二级索引

**聚簇索引和非聚簇索引【区别】**

聚簇索引 = 将索引结构和数据放在一起的索引

> 【优点】：查询效率高，定位到索引树叶节点，直接找到数据
>
> 【缺点】：索引列更新时，维护代价大
>
> 【主键索引】属于【聚簇索引】

----

非聚簇索引 = 索引结构和数据分离的索引

> 【优点】：更新代价更小
>
> 【缺点】：需要二次查询 -> 例如 二次索引需要在主键索引中再次回表查询
>
> 【二级索引】：属于【非聚簇索引】

---

主键索引

> 主键索引 叶子节点 = 「key, 其他Data数据」
>
> InnoDB中如果没有指定表的主键，则检测表是否有唯一索引
>
> 如果有, 则该字段默认 = 主键
>
> 如果没有，则InnoDB自动创建6B的自增主键

二级索引

>二级索引叶子节点 = {key, 主键ID }
>
>二级索引查询【过程】
>
> 	1. 【非聚集索引】中查询主键ID
> 	2. 【回表】：根据主键ID在【聚集索引】中查询整行记录

#### 6.6 最左前缀

联合索引 是由多个列组成。如（name, age）

查询时，列值【从左到右】匹配索引

遇到【范围查询】（> < between like左匹配）后，不可进一步匹配。

#### 6.7 覆盖索引

在非聚集索引的叶子节点中所含的列值是要查询的列值，不用进行回表。直接返回即可。

#### 6.8 为什么不对每个列创建索引

1. 数据CRUD时，索引需要动态维护
2. 索引占据物理空间，尤其聚簇索引



### 数据库三大范式

1. 第一范式：每个列不可分离
2. 第二范式：非主键完全依赖主键
3. 第三范式：非主键只依赖主键，不依赖非主键

### 索引应用场景

ALTER TABLE add index（字段名） 创建索引

1. WHERE
   + WHERE 筛选字段进行查询时
   + 如果该字段建立索引，则查询效率更高
2. ORDER BY
   + 使用Order by将查询结果按照某个字段排序时
   + 如果该字段没有建立索引，查询出的所有数据使用外部排序，涉及磁盘IO，则效率低下
   + ALTER TABLE table_name ADD INDEX index_name (column_list)
   + 由于索引有序，所以按照索引顺序逐条读出数据
3. 索引覆盖
   + 【查询的字段】都建立过索引
   + 引擎会直接在索引表中查询而【不访问原始数据】
   + 尽可能在select后只写必要的查询字段，以增加索引覆盖几率

### 创建索引原则

1. 字段 基数大
2. 字段 重复值小
3. 字段 频繁作为【查询条件】
4. 字段 更新少
5. 最左匹配原则：
   + MySQL对索引的列值 从左到右匹配，直到遇到范围查询就停止
6. 尽量扩展索引，而非新建索引

### 大表优化

explain 查看执行计划，其中包含了是否使用索引，使用了什么索引，使用索引的相关信息等

`大表优化`[How](https://blog.csdn.net/u011277123/article/details/82348817)

1. 限定数据范围
   + 查询语句，通过查询条件限制数据范围
2. 数据库主从同步，读写分离
   + 多个服务器部署MySQL
     + 一台服务器为【主库】，负责【写数据】
     + 一台服务器为【从库】，负责【读数据】
   + 主从同步实现
     + 【主库A】数据库时间存储在 日志系统A中，传输日志文件
     + 【从库】接受文件并写入本地日志系统，然后将【数据库事件】在从库MySQL中完成
3. 垂直分区
   + 优点：一行记录的数据量变少，在查询时IO次数减少
   + 缺点：
     + 主键冗余
     + 引起Join操作
4. 水平分区（有难度）
   + 将【行数据】分组存储到不同【库 || 表】( 最好分库）
   + 【缺点】
     + 查询时，通常需要【多个表名】+ 【UNION操作】
     + 跨库JOIN性能很差
     + 【跨库】的【事务支持】，逻辑复杂度和性能代价都很大

`分库分表后的问题`

1. 【跨节点】的count, order by, group by  等【聚合函数】逻辑复杂
2. 【跨库】的join性能代价大
3. 【主键ID问题】：MySQL原先主键自增机制，跨库情况下，存在主键重复的问题
   + 若曹勇UUID作为主键，则UUID主键占用内存过大
   + 多个库采用跨步自增
   + ...
4. 【事务支持】

`主从分布，读写分离`

1. 作用 = 「负载均衡 + 数据备份 + 高可用」
2. 流程：
   + 主库的【数据库事件】记录在二进制的binlog，binlog传输给从库
   + 从库读取binlog内容到本地日志系统的relaylog
   + 从库执行 relay log中的SQL语句，实现主从同步

### SQL生命周期

1. 应用服务器与数据库服务器简历一个连接，应用服务器发送SQL请求
2. 数据库进程拿到【SQL请求】，通过【连接器】验证SQL语句是否具有【权限】
3. 【分析器】进行词法分析和语法分析
   + 词法分析 提取SQL语句关键元素：SELECT、表名、查询条件等
   + 语法分析 判断SQL语句是否正确：判断关键词是否准确
4. 【优化器】生成SQL【执行计划】
5. 【执行器】按照执行计划，将数据读取到内存并进行逻辑处理
6. 通过连接，将数据传输给应用服务器
7. 断开连接

### MySQL锁

1. 表锁
2. 行锁
   + Record Lock：单个数据行的锁
   + Gap Lock：锁定范围，不包括记录本身
   + Next-Key lock：Record + gap 结合，锁定一个范围，并锁定记记录本身

### count* count1 count(col)区别

1. Count (expression) = 聚合函数
   + 逐行检测expression是否=null，expression != null则计数器加1
2. count(1) 和 count(*) 作用相同
   + count(1) 每行expression = 1， NOT NULL, count(1) 作用=统计总行数
   + count(\*) 并非统计每行所有列值是否为null, 列值全为null的数据行不存在，因此count(\*)=数据行不存在
   + 因此count(\*) = 统计总行数
3. count(1)  count(\*)经过优化器指定的执行计划相同，两者效率相同
   + 在没有二级索引情况下，通过主键索引统计总行数
   + 如果有二级索引，则优先选择【最窄】二级索引统计总行数
   + 主键索引 叶节点 = 「主键ID, 其他列」
4. count(col) 逐行检测col是否=null
   + 因此 count（col）统计非null列的总行数，对col建立非聚集索引，可以优化查询效率

### Explain 返回的結果

**type** 『引擎查找表』的方式

```mysql
all, index, range, ref, eq_ref, const
# 从左到右，它们的效率依次是增强

all  #全表扫描
index #全索引扫描
range #范围扫描：    【索引】 + 【范围查询】
ref #小范围扫描：    【可能重复】 的 【普通索引】 + 【表联结情况】
eq_ref #单条数据扫描：【主键 || 唯一】索引 + 【表联结情况】
const #单条数据扫描： 【主键 || 唯一】索引
```

**key**

```mysql
MySQL #使用的索引
```

**rows**

```mysql
MySQL #执行查询的行数，数值越大性能越差
```

**extra**

```mysql
Using index #使用覆盖索引
Using Where #使用WHERE过滤
Using temporary #使用临时表，建议优化
Using filesort #对查询结果【外部排序】，而非根据索引有序读取。建议优化
```

### SQL优化

1. WHERE的优化
   + 全表扫描
     + WHERE，ORDER BY 涉及的列上 建立索引
   + WHERE条件中避免使用的判断【这些判断，会使得引擎（放弃索引），全表扫描】

```mysql
is null, !=, OR, in //非连续in集合会放弃索引，全表扫描
```

2. WHERE条件中避免【运行时解析】的变量
   + 原因：执行计划在【编译期】指定，【运行时解析】的变量不能作为索引输入项，因此采用全表扫描
     + 参数
       + WHERE num = @num
     + WHERE条件左侧 避免 函数调用+算数计算
       + WHERE num = 100 + 2
       + WHERE substring(num, 1, 3) = 'abc'

### 超大分页

超大分页 = Limit 10000, 10

MySQL并非跳过 = offset行，而是取offset + N行，然后返回放弃前 offset行，返回 N 行

那当 offset 特别大的时候，效率低下

【优化方法】先快速定位主键，然后再关联

### SQL优化

1. 慢查询日志，查看开销大的SQL

   ​	set GLOBAL slow_query_log = on

2. 开销大原因 = 「

   + 【原因一】SQL语句，是否加载额外的数据

     + 【例子】未使用WHERE范围限制、Limit分页过大、使用「is NULL, !=, OR」触发全表扫描
     + 【优化】修改SQL语句

   + 【原因二】未命中索引、使用的索引有持久化

     + ```mysql
       SELECT A,B,C FROM t WHERE A=? AND B=? #或者 ORDER BY、ON的列上是否建立索引
       ```

     + 【优化】explain查询执行计划，创建 || 选择其他索引，使得SQL语句尽可能地命中索引

   + 【原因三】SQL语句无法优化【大表情况】

     + 分库分表
     + 主从同步，读写分离

   」
